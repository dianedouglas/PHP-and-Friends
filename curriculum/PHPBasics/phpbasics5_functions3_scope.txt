Let's get this out of the way. Everyone is confused by scope at first. If someone says they weren't, they are a liar. It's really ok, you'll get it. With that in mind, take a breath, here we go.

Scope is essentially a fancy word for the programming equivalent of "What happens in Vegas stays in Vegas." Except that instead of Vegas, we have curly brackets: `{}`.

I know, your brow just furrowed. Bear with me. 

Anything you define inside of a set of curly brackets is only visible to code that is also inside of that set of curly brackets, unless stated otherwise. For example, if you try do this inside your test file:

```
function addFive($a_number){
	$sum = 5 + $a_number;
}

addFive(2); 
echo "The sum of 5 and 2 is: $sum";
```

Your website will tell you that the sum of 5 and 2 is just blank space. Why? We didn't return a value from our function. It takes input ($a_number) but has no output. We calculated the sum by adding 5 to our input value, but we just stored it in a variable created inside that function. Because that variable `$sum`'s _scope_ is limited to the function `addFive()` the rest of the code can't see it, and thinks that $sum is an unused variable when we try to print it out. 

When the function addFive is run, the variable $sum is created, but when the function finishes running, that variable automatically evaporates back into the ether of your computer's memory.

The other way is true too:

```
$number_to_add = 5;

function addNumber($a_number){
	return $a_number + $number_to_add;
}

echo addNumber(9);
```

This time we have output - we're returning the sum of the two numbers. But, because `$number_to_add` was defined outside of the function's curly brackets, the code inside of the function can't see it. 

Variables need to have a scope to exist in so that they don't interfere with each other. When I'm thinking about variable scope, I like to think of my program as a house. At first it's just a studio apartment - it has one room.  That one room is the _global scope_. It is outside of all the curly brackets.

Any time I use curly brackets I add a room to the house. Any variables created inside that new room can only stay in that room unless I tell them otherwise. Only code inside that room can interact with them. Likewise, variables I created in the first room of the house, the global scope, can't interract with variables inside of other rooms.

What if I want my variables to be able to walk through walls and break these rules of scope? There are three ways. Using global variables, static variables and references. Each is good for different situations.

Global variables:

If you declare a variable inside of a function using the 'global' keyword, then that tells the function to search in the first room of the house for a variable of that samae name and access that. 

Static variables: 

If you declare a variable inside of a function using the 'static' keyword, that means that it doesn't evaporate at the end of the function. It still can't be acessed from outside of the function, but it can be used over and over again while retaining its value.

References:

Say that we have a number, declared in the global scope and several functions declared to change it in various ways like this:

```
$favorite_number = 1;

function double_favorite_number(){
	global $favorite_number *= 2;
}

function subtract_one(){
	global $favorite_number -= 1;
}

function opposite_sign(){
	global $favorite_number *= -1;
}

```
Say the whole website is about what my favorite number is. For some reason. And every time the user clicks a button one of those functions changes what my favorite number is. It makes sense to have one variable to hold my favorite number and modify that directly, where these functions are only designed to work with that one number. This is a good use for the global keyword.  

However, say that you have a game where there are two favorite numbers. And you don't know which one the user will be modifying. This is a good time to pass your functions references. Like so:

```
function double_favorite_number($&number_to_double){
	global $number_to_double *= 2;
}

function subtract_one($&number_to_subtract_from){
	global $number_to_subtract_from -= 1;
}

function opposite_sign($&opposite_number){
	global $opposite_number *= -1;
}

```
//here show how it's different to print the code this way than without reference. 
//double check order of the $& 
//now functions can take any number and modify it directly instead of a copy.



Here's all 3 kinds showed next to each other:

```
$favorite_number = 1;

function double_favorite_number(){
	global $favorite_number *= 2;
}

function double_any_number($&number_to_double){
	
}

function sum_all_numbers($number_to_add){
	static $total;
	$total += $number_to_add;
	echo "The current total is $number_to_add";
}